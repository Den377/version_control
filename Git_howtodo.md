# ПОДСКАЗКИ ПО GIT

## Что такое GIT?
Система контроля версий, или VCS (SCM), — программа, позволяющая контролировать изменения в проекте.
Git - один из примеров системы контроля версий: он позволяет хранить, изменять и анализировать историю проекта.

## Настройки GIT
Чтобы участникам проекта было понятно, кто и какие изменения вносил, нужно представиться и указать имя пользователя и адрес электронной почты.
Вы можете указать любую электронную почту и любое имя. Сделать это можно с помощью команды:
```sh
git config --global
```
от англ. configuration — «конфигурация», «настройка», с ключом --global (англ. «глобальный»). При этом не имеет значения, в какой директории вы находитесь прямо сейчас: вызов git config --global сработает везде.
В качестве значения user.name нужно указать своё имя или никнейм. Для настройки параметра user.email указывают электронную почту.
```sh
$ git config --global user.name "User Namovich" 
# имя или ник нужно написать латиницей и в кавычках

$ git config --global user.email username@yandex.ru
# здесь нужно указать свой настоящий email 
```
Вывести содержимое файла конфигурации Git можно той же командой:
```sh
git config --list
```
В ответ командная строка покажет текущие значения настроек
## Инициализация репозитория
Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием (от англ. repository — «хранилище»). Для этого следует переместиться в неё и ввести команду:
```sh
git init
```
от англ. initialize — «инициализировать».
Например, создаем папку first-project и делаем её Git-репозиторием: переходим в неё с помощью команды cd и выполняем git init.
```sh
$ cd ~/dev/first-project # перешли в нужную папку

$ git init # создали репозиторий 
```
Создать папку можно в любом месте на компьютере. Но в этом случае не забываем менять путь, который ведёт к этой папке. Помните, что не рекомендуется создавать репозиторий Git внутри другого Git-репозитория. Это может вызывать проблемы с отслеживанием изменений.

Команда git init выведет сообщение вида Initialized empty Git repository in <*ваша папка с проектом*>/.git/ (англ. «инициализирован пустой Git-репозиторий в <*ваша папка*>/.git/»). В подпапке .git Git будет хранить всю служебную информацию.

Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку .git.
```sh
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git 
```
Будьте осторожны: в подпапке .git хранится история изменений. Если удалить .git, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.

## Проверка состояния репозитория
После инициализации репозитория запустите команду:
```sh
git status
```
от англ. status — «статус», «состояние» — она показывает текущее состояние репозитория.

Команда git status выведет:
* название текущей ветки: On branch master или On branch main;
* сообщение о том, что в репозитории ещё нет коммитов: No commits yet;
* сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — nothing to commit (create/copy files and use "git add" to track).
## Добавляем файлы в репозиторий
Если создать новый файл/файлы и запустить команду git status, то Git сообщит, что в такой то папке есть untracked files (от англ. track — «следить», untracked — «неотслеженный», «неотслеживаемый») — ещё не отслеживаемые файлы.
Состояние untracked значит, что Git ещё не хранит информацию о версиях файла и не может отследить, как он изменялся.

Добавить в репозиторий файл/файлы можно с помощью команды:
```sh
git add <имя файла>
```
Либо:
```sh
git add --all
```
Ключ, или флаг, --all позволяет подготовить к сохранению все файлы в репозитории.

Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке в Bash позволяет точка (.).
```sh
$ git add . # добавить всю текущую папку
```
Если после добавления файла в репозиторий ввести команду git status, то мы увидим, что этот файл, отмечен зелёным,то есть теперь отслеживается и готов к сохранению. Но сохранения пока не произошло, потому что команда git add только запоминает текущее содержимое (контент) файла.

Если сейчас отредактировать любой из «зелёных» файлов в папке first-project, он перейдёт в состояние modified (англ. «изменённый») и будет и в «зелёном», и в «красном» списках. Чтобы запомнить новое состояние файла, нужно снова ввести команду git add и передать в качестве параметра имя изменённого файла или ключ --all. Теперь файл снова готов к сохранению! Будет сохранена последняя добавленная версия.

Подытожим:
* Команда git add позволяет подготовить файл к сохранению.
* Команда git add --all подготовит к сохранению сразу все файлы.
* С помощью git add . можно добавить в репозиторий текущую папку со всеми файлами.

Команда git add не сохраняет содержимое файлов в репозитории. Само сохранение, или фиксацию состояния файлов, называют коммитом (от англ. commit — «совершать», «фиксировать»). «Сделать коммит» значит сохранить текущую версию файла. 
 Если провести аналогию, команду git add можно сравнить с добавлением товаров в корзину в интернет-магазине, а коммит — с оформлением и оплатой заказа.
## Рабочая папка
В графическом интерфейсе всегда ясно, где именно вы находитесь в файловой системе. Если перед вами рабочий стол, значит, вы в папке «Рабочий стол». Если открыта папка «Документы» — вы в ней.
В командной строке вы тоже всегда находитесь в какой-то папке — просто этого не видно. Узнать, где вы сейчас, поможет команда:
```sh
pwd
```
от англ. print working directory — «показать <u>рабочую</u> папку». Она выводит путь к <u>текущей</u> директории.
С помощью терминала вы всегда можете перейти к домашней директории. Для этого нужно ввести команду:
```sh
cd ~
```
от англ. change directory — «сменить директорию» и символ тильда ~ — обозначение домашней директории.
Чтобы открыть файл, находящийся в определенной директории, необходимо перейти в нее с помощью команды cd. Например, если ваш файл находится на рабочем столе, введите команду:
```sh
cd C:/Users/Имя_пользователя/Desktop
```
Файловая система компьютера состоит из папок, или директорий. В них могут находиться другие папки и файлы.
Когда вы открываете папку через графический интерфейс операционной системы, вы сразу видите её содержимое. В случае с консолью для отображения файлов и папок используют команду:
```sh
ls
```
от англ. list directory contents — «отобразить содержимое директории» для Linux и MacOs
```sh
dir
```
для Windoms

То есть, через консоль можно выполнять те же операции, что и с помощью классических средств работы с операционной системой. А именно:
* менять директории командой cd;
* выводить содержимое директорий с помощью ls и dir.

## Удаление файлов и папок
Чтобы удалить файл, нужно напечатать команду:
```sh
rm
```
от англ. remove — «удалить» и передать ей имя файла, например:
```sh
rm example.txt
# удалили файл example.txt из текущей папки.
```

Удалить папку можно командой:
```sh
rmdir
```
от англ. remove directory — «удалить директорию». Не забываем указать имя папки.

Если в папке, которую вы пытаетесь стереть, есть какие-то файлы, то командная строка не удалит её и выведет сообщение о том, что папка не пуста (англ. Directory not empty). В этом случае команда:
```sh
rm -r
```
-r — от англ. recursive, «рекурсивный», рекурсивно удаляет файлы и папки. Это значит, что удаление будет последовательно применяться к каждому из элементов в этой папке — пока не сотрёт их все. Затем команда удалит пустую директорию.

## Команды из буфера
Чтобы обратиться к последней введённой команде, нажмите на клавиатуре стрелку вверх (↑). Если нажать ещё раз, появится предпоследняя команда; ещё раз — предпредпоследняя; и так далее. Чтобы вернуться — например, от предпоследней команды к последней, — нажмите стрелку вниз (↓).

## Автозаполнение
Необязательно заучивать все команды наизусть. Если нужно найти какую-нибудь из них, достаточно вспомнить, с каких букв она начинается. Можно набрать их в командной строке и дважды нажать клавишу Tab. Терминал покажет список всех команд, которые начинаются с этих символов.
Tab автоматически дописывает не только команды, но и пути. Начните печатать имя папки или файла (они должны быть в той же директории) и нажмите Tab. Терминал заполнит имя автоматически.
Если этого не происходит, значит, есть несколько файлов или папок, которые начинаются так же. Нажмите Tab ещё раз, и вы увидите их список. Терминал не знает, как ему дозаполнить такой ввод и что именно выбрать, поэтому показывает все варианты, чтобы вы могли уточнить запрос.

## Коммит
Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться».
Сделать коммит можно командой:
```sh
git commit
```
c ключом -m (от англ. message — «сообщение»), который присваивает коммиту сообщение.
Сообщение коммита выполняет те же функции — улучшает понимание и упрощает навигацию. Оно пишется после ключа -m в кавычках.
```sh
$ git commit -m 'Мой первый коммит!' 
```
После нажатия Enter текущая версия файлов будет сохранена в репозитории с сообщением Мой первый коммит!. Коммит (по названию команды git commit) — это по сути список файлов с их контентом.

Ещё раз о разнице между git add и git commit
Сначала команда git add сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды git commit происходит само сохранение. 

Просмотреть историю коммитов можно с помощью команды:
```sh
git log
```
от англ. log — «журнал [записей]»

По умолчанию git log выводит коммиты в обратном хронологическом порядке — последние коммиты оказываются первыми сверху. В этом можно убедиться, если посмотреть на дату и время их создания.

У команды git log есть разные опции, самая используемая из них — --oneline.
```sh
git log --oneline
```
Она показывает хеш в укороченном формате, ветку, в которой сделан коммит, а также текст коммита.

## Хэш
**Хеш — основной идентификатор коммита**

Хеширование (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).
Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.
Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.
Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 
0—9 и латинских букв 𝐴—𝐹 (неважно, заглавных или строчных). Она обладает следующими важными свойствами:
* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

## Перемещение по коммитам
В Git под термином checkout подразумевают <u>переключение</u> между различными версиями целевого объекта.
```sh
git checkout
```
Данная команда работает с тремя различными объектами: файлами, коммитами и ветками. Под переключением также обычно понимают действие, связанное с выполнением команды git checkout. Рассмотрим, каким образом команду git checkout можно использовать для просмотра старых коммитов.

Git можно рассматривать как инструмент для управления временной шкалой. Коммиты — это снимки моментов времени или точек интереса на временной шкале истории проекта. Кроме того, с помощью веток можно управлять несколькими временными шкалами. Когда вы выполняете операцию отмены в Git, вы, как правило, перемещаетесь назад во времени или на другую временную шкалу, где ошибок не было.

Когда в проекте сохранена история коммитов, можно повторно оценивать и анализировать любые ранее выполненные коммиты. Один из лучших инструментов для просмотра истории репозитория Git — команда git log. Допустим, история вашего проекта выглядит примерно так:
```sh
b7119f2 Continue doing crazy things
872fa7e Try something crazy
a1e8fb5 Make some important changes to hello.txt
435b61d Create hello.txt
9773e52 Initial import
```
Каждый коммит имеет уникальный идентифицирующий хеш. Эти идентификаторы используются для перемещения по временной шкале коммитов и возвращения к коммитам. По умолчанию git log показывает только коммиты текущей выбранной ветки.
После того как вы нашли ссылку на нужный коммит в истории, для перехода к нему можно использовать команду git checkout. Команда git checkout — это простой способ «загрузить» любой из этих сохраненных снимков на компьютер разработчика.
Например, для просмотра коммита «Make some important changes to hello.txt» можно использовать команду git checkout в следующем виде: 
```sh
git checkout a1e8fb5
```
Это приведет к тому, что ваш рабочий каталог будет в точности соответствовать состоянию коммита a1e8fb5. Вы можете просматривать файлы, компилировать проект, запускать тесты и даже редактировать файлы, не боясь потерять текущее состояние проекта. Никакие внесенные здесь изменения не будут сохранены в репозитории. Чтобы продолжить разработку, необходимо вернуться к текущему состоянию проекта:
```sh
git checkout main
```

## Статусы файлов в Git
Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.
* __UNTRACKED__ (англ. «неотслеживаемый»). Мы говорили, что новые файлы в Git-репозитории помечаются как *__untracked__*, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
* __STAGED__ (англ. «подготовленный»).   После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
* __TRACKED__ (англ. «отслеживаемый»). Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
* __MODIFIED__ (англ. «изменённый»). Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

**Для файлов в состояниях staged и modified обычно не указывают, что они также tracked, потому что это состояние подразумевается.**

Типичный жизненный цикл файла в Git
![1](GIT.png)

## Что такое ветка?
Ветка (англ. branch) — это изолированный поток разработки проекта. В таком потоке можно проверять разные идеи, тестировать новую функциональность и так далее.
Ветки позволяют экспериментировать с проектом в Git, но при этом сохранять репозиторий в стабильном состоянии. Каждый член команды может работать в своей ветке и не мешать другим: коммиты, которые он сделает, не будут видны из других веток. А когда работа будет доделана, ветки можно соединить.

Основная, стабильная версия проекта хранится в главной ветке __main__ или __master__. Она появляется автоматически при создании репозитория. Часто все новые ветки в репозитории отходят от main, хотя это не является правилом.

Команда 
```sh
git branch
```
выводит все ветки, которые есть в проекте. Звёздочкой (*) отмечено, в какой ветке вы находитесь в текущий момент.

Коротко подытожим:
* Ветка — это последовательность независимых изменений.
* Благодаря веткам несколько человек могут работать над одним репозиторием и не мешать друг другу. А ещё ветки помогают декомпозировать большую и страшную задачу на маленькие и понятные.
* Основная версия проекта хранится в главной ветке main (или master).
* С помощью команды git branch можно посмотреть, какие в проекте есть ветки и в какой из них вы сейчас находитесь.

Команда 
```sh
git branch <название_ветки>
```
создаёт новую ветку.

Команда
```sh
git checkout <название_ветки>
```
позволяет переключаться на другую ветку.

Можно создать ветку и сразу же перейти в неё командой
```sh
git checkout -b <название_ветки>
```
Ветка в Git — это указатель на коммит. Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.

## Объединение и удаление веток
Представьте, что закончили разработку новой функциональности в отдельной ветке и готовы объединить её с главной — добавить свои изменения в основную версию проекта. Этот процесс называется слиянием веток.
«Мёржить» (от англ. merge — «сливать», «поглощать») ветки, то есть объединять их можно с помощью команды
```sh
git merge <название_ветки>
```
После того как произошло слияние, ветку-донора можно удалить. Для этого в основной ветке введите команду
```sh
git branch -D <название_ветки>
```
Если в момент удаления вы будете находиться в той ветке, которую хотите удалить, Git сообщит об ошибке: can not delete branch (англ. «не получается удалить ветку»).

У команды git branch -D есть более безопасный вариант с флагом -d. Он удалит ветку только если она была полностью объединена с другой — то есть если две ветки стали (или изначально были) частью одной истории. Например, если вы нечаянно создали ветку с неправильным названием, её можно удалить через git branch -d <имя_ветки>.

### Конфликт
Когда сразу несколько членов команды работают над одним и тем же фрагментом проекта в разных ветках, при слиянии могут происходить конфликты. Допустим, вы решили отредактировать параграф текста и исправить опечатки. В этот момент ваш коллега поменял тот же самый параграф в соседней ветке change/github-info и влил изменения в main.
После завершения работы вы делаете финальный коммит в своей ветке edit/fix-typoes, переходите в основную и пытаетесь выполнить слияние. Но в терминале появляется такое сообщение
```sh
$ git commit -m "Исправить опечатки" && git checkout main
$ git merge edit/fix-typoes
Auto-merging pages/table-of-content.txt # тут Git самостоятельно внёс изменения 
CONFLICT (content): Merge conflict in github.txt # здесь возник конфликт
Automatic merge failed; fix conflicts and then commit the result # слияния не произошло
```
На схеме эта ситуация может выглядеть так.
![2](Конфликт.png)
Если Git не может провести слияние изменений автоматически, он сообщает о конфликте. Конфликт — это ситуация, в которой один или несколько человек модифицировали один и тот же файл. При этом результаты таких модификаций оказались несовместимы и разобраться в том, какой из вариантов правильный, может только человек.

Во время слияния Git сам подсвечивает файлы, которые не смог объединить. Чтобы разобраться в ситуации, нужно сделать следующее:
Заглянуть в файл, где произошёл конфликт.
Изучить обе стороны конфликта — вашу версию и версию вашего коллеги. Ваша задача — правильно собрать две версии в итоговую, так чтобы изменения обеих сторон не потерялись. Новая версия станет текущей актуальной.
Вручную удалить или подправить неактуальные изменения, если они есть.
Подготовить изменения к сохранению и сделать коммит.

## Что такое Git Hub?
GitHub — платформа для хранения IT-проектов и совместной работы над ними с использованием Git. По сути, это сайт, куда можно загрузить файлы своего проекта для обмена с другими людьми. С английского языка слово hub переводится как «узловая станция».

GitHub подходит, чтобы отточить навыки работы с Git. Здесь можно завести аккаунт и вместе со своей командой работать над любыми задачами. Можно создавать проекты разных типов: 
приватный — только для вас;
командный — только для членов команды;
публичный — будет виден всем.
Также можно присоединиться к чужому  и работать над ним вместе с другими людьми со всего мира. 

**Git** и **GitHub** — это два разных проекта, которые развиваются независимо друг от друга. 
Git:
- консольный инструмент для работы с локальными и удалёнными репозиториями;
- проект с открытым исходным кодом.
GitHub:
- платформа для размещения удалённых репозиториев;
- принадлежит компании Microsoft.
Кроме GitHub, есть и другие платформы для командной работы. Например, GitLab и Bitbucket

Для того, чтобы начать работать с GitHub, необходимо зарегистрироваться на сайте [github](https://github.com/) и создать свой аккаунт

## Создаём удалённый репозиторий
1. Зайдите в свой профиль по ссылке https://github.com/username, где username — имя, которое вы указали при регистрации. Эта страница — презентация вас и ваших проектов. Её видят другие пользователи. Надпись You don't have any public repositories yet (англ. «у вас пока нет публичных репозиториев») сообщает, что пока у вас нет проектов.

2. Создайте репозиторий. Для этого перейдите на вкладку Repositories (англ. «репозитории»), а затем нажмите на зелёную кнопку New (англ. «новый») справа. Открылось окно создания нового репозитория. Назовите его first-project. Название удалённого репозитория необязательно должно совпадать с именем папки проекта у вас на компьютере. Но чтобы не путаться, будем называть их одинаково. Другие поля вам пока не понадобятся. Смело нажимайте на зелёную кнопку Create repository (англ. «создать репозиторий») внизу.

Готово! Удалённый репозиторий создан. Страница с ним открывается автоматически. 

Осталось связать удалённый репозиторий с локальным, который уже есть на вашем компьютере. GitHub предоставляет для этого инструкцию (пункт …or push an existing repository from the command line).

Привязать удалённый репозиторий к локальному
```sh
git remote add
```
Убедиться, что репозитории связаны
```
git remote -v
```

## Как отправить изменения на удалённый репозиторий
Если мы подготовили файлы с помощью git add, закоммитили их с комментарием командой git commit -m на локальном репозитории, то осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда:
```sh
git push
```
В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.
```sh
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте заменить main на master. 
```
